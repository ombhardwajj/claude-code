name: Port Repo to Rust

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'GitHub repo URL of the Python or C++ project to port (e.g., https://github.com/dbarnett/python-helloworld)'
        required: true
        type: string

jobs:
  port:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo (for any custom scripts if needed later)
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl python3 git

      - name: Fetch repo digest using gitingest or clone
        run: |
          GITINGEST_URL="${{ inputs.repo_url }}"
          GITINGEST_URL="${GITINGEST_URL/github.com/gitingest.com}"
          curl -s "$GITINGEST_URL" > repo_digest.txt
          if [ ! -s repo_digest.txt ]; then
            echo "Warning: Gitingest failed, attempting to clone repo"
            REPO_NAME=$(basename ${{ inputs.repo_url }} .git)
            git clone ${{ inputs.repo_url }} $REPO_NAME
            find $REPO_NAME -type f \( -name "*.py" -o -name "*.cpp" \) -exec cat {} \; > repo_digest.txt
            if [ ! -s repo_digest.txt ]; then
              echo "Error: No Python or C++ files found in repo"
              exit 1
            fi
          fi
          echo "Digest content:"
          cat repo_digest.txt

      - name: Call Gemini API to port to Rust
        run: |
          PROMPT="The following is a codebase digest (from Python or C++). Port it to a single Rust file (main.rs) for simple scripts or a full project with Cargo.toml for complex ones. Output strictly in this format, with no extra text or explanations:
          ---
          File: <path, e.g., main.rs or Cargo.toml>
          Content:
          \`\`\`
          <complete file content>
          \`\`\`
          ---
          Ensure the code compiles with rustc or cargo build.
          
          Codebase digest:
          $(cat repo_digest.txt)"
          
          RESPONSE=$(curl -s https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${{ secrets.GEMINI_API_KEY }} \
            -H 'Content-Type: application/json' \
            -d '{
              "contents": [{
                "parts": [{
                  "text": "'"$PROMPT"'"
                }]
              }],
              "generationConfig": {
                "temperature": 0.1,
                "maxOutputTokens": 8192
              }
            }')
          
          echo "$RESPONSE" > response.json
          echo "Gemini API response:"
          cat response.json
          jq -r '.candidates[0].content.parts[0].text // .error.message // "Error: API call failed"' response.json > rust_project.txt
          if grep -q "Error" rust_project.txt; then
            echo "Error in API response:"
            cat rust_project.txt
            exit 1
          fi
          echo "Parsed LLM output:"
          cat rust_project.txt

      - name: Parse LLM response to create Rust files
        run: |
          python3 - <<EOF
          import re
          import os

          with open('rust_project.txt', 'r') as f:
              content = f.read().strip()

          # Try structured format first
          sections = re.split(r'---\s*', content)
          files_created = False
          for section in sections:
              section = section.strip()
              if not section:
                  print("Skipping empty section")
                  continue
              
              lines = section.split('\n')
              if not lines or not re.match(r'File:\s*.+', lines[0]):
                  print(f"Skipping invalid section: {section[:50]}...")
                  continue
              
              file_path = lines[0].replace('File:', '').strip()
              content_start_idx = next((i for i, line in enumerate(lines) if re.match(r'Content:\s*', line)), None)
              if content_start_idx is None:
                  print(f"No Content: found for file {file_path}")
                  continue
              
              code_lines = lines[content_start_idx + 1:]
              if code_lines and re.match(r'\s*```.*', code_lines[0]):
                  code_lines = code_lines[1:]
              if code_lines and re.match(r'\s*```.*', code_lines[-1]):
                  code_lines = code_lines[:-1]
              
              code = '\n'.join(line.rstrip() for line in code_lines).strip()
              if not code:
                  print(f"No code content for file {file_path}")
                  continue
              
              print(f"Creating file: {file_path}")
              os.makedirs(os.path.dirname(file_path), exist_ok=True)
              with open(file_path, 'w') as fw:
                  fw.write(code)
              files_created = True

          # Fallback: if no files created and content looks like Rust code, save as main.rs
          if not files_created and 'fn main()' in content:
              print("No structured files detected, saving as main.rs")
              with open('main.rs', 'w') as f:
                  content = re.sub(r'```rust\n|```', '', content).strip()
                  f.write(content)
          EOF

      - name: Set up Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable

      - name: Compile generated Rust project
        run: |
          echo "Listing directory contents:"
          ls -la
          if [ -f "Cargo.toml" ]; then
            echo "Found Cargo.toml, building with cargo"
            cargo build --verbose
          else
            echo "No Cargo.toml found; assuming single-file project"
            if ls *.rs 1> /dev/null 2>&1; then
              echo "Found .rs files:"
              ls *.rs
              rustc *.rs
            else
              echo "Error: No Rust files generated"
              exit 1
            fi
          fi

      - name: Upload Rust project artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: rust-project
          path: .
          if-no-files-found: warn
```
